import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Scanner;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;

/**
 * Node is a peer object in a p2p network.
 * It acts both as a client and a server.
 * In this Gnuetella inspired network, node
 * performs basic distributed operations. PING,
 * PONG, QUERY, QUERYHIT, GET, REPLY.
 * @author wmabebe
 *
 */
public class Node implements Comparable{
	/**
	 * Unique ID that identifies this node.
	 */
	private long id;
	/**
	 * Node's ip address
	 */
	private String host;
	/**
	 * Node's udp listening port.
	 * Node also has a TCP port in FileServer.java.
	 * tcpPort = udpPort + 1000.
	 */
	private int port;
	/**
	 * Neighbors list. This list is synchronized because
	 * it's accessed by multiple threads.
	 */
	private List<Neighbor> neighbors = Collections.synchronizedList(new ArrayList<Neighbor>());
	
	/**
	 * 2.0 Shared directory.  This directory contains all
	 * the files shared by this node.
	 */
	private String DIR_NAME;
	
	/**
	 * Max number of allowed neighbors for a node.
	 */
	public static final int MAX_NEIGHBORS = 2;
	
	/**
	 * Node0's ID is set to this value instead of randomizing.
	 */
	public static final int NODE_0_ID = 0;
	
	/**
	 * Sleep time is the amount of seconds a
	 * node sleeps in between pinging neighbors.
	 */
	public static final int SLEEP_TIME = 5;
	
	/**
	 * 4K buffer size for downloading files;
	 */
	public static final int BUFFER_SIZE = 4096;
	
	/**
	 * Maintain a set of PING id's generated by this node.
	 * This allows the node to realize a PONG
	 * message, with a prev_id value in this set,
	 * is meant for this node. Routinely clear this
	 * set to save memory. Clear every 100 PINGS.
	 */
	Set<Long> PING_CACHE = Collections.synchronizedSet(new HashSet<Long>());
	
	/**
	 * Maintain a set of QUERY id's generated by this node.
	 * This allows the node to realize a QUERYHIT
	 * message, with a prev_id value in this set,
	 * is meant for this node. Routinely clear this
	 * set to save memory. Clear every 100 QUERies.
	 */
	Set<Long> QUERY_CACHE = Collections.synchronizedSet(new HashSet<Long>());
	
	/**
	 * Maintain a set of SEEN_MSGS, to make sure
	 * node isn't servicing the same message twice.
	 * Routinely clear this set to save memory.
	 * Clear every 1000 Messages.
	 */
	Set<Long> SEEN_MSGS = Collections.synchronizedSet(new HashSet<Long>());
	
	/**
	 * Maintain a pool of neighbors that may be
	 * contacted in case contact is lost with 
	 * active neighbors.
	 */
	Set<Neighbor> pool = Collections.synchronizedSet(new HashSet<Neighbor>());
	
	
	/**
	 * This map keeps track of the liveliness of
	 * remote neighbors. It maps NeighborID to LastPongTime.
	 * Neighbors that have not PONGed back in 2X the acceptable
	 * time limit will be considered stale and removed from
	 * the neighbors list and into the pool. A separate thread
	 * will handle neighborhood liveliness.
	 */
	HashMap<Neighbor,Long> live = new HashMap<Neighbor,Long>();	
	
	/**
	 * A list of all files shared by this node.
	 * This is basically database 2.0. Instead of
	 * maintaining a database of Strings, we maintain
	 * a database of files instead.
	 */
	HashSet<String> files = new HashSet<String>();
	
	/**
	 * A queue of requested files. The TCP file server
	 * thread will dequeue this queue when firing a new
	 * fileHandler thread.
	 */
	ArrayBlockingQueue<String> fileQueue = new ArrayBlockingQueue<String>(10);
	
	/**
	 * Node constructor initializes instance variables. 
	 * @param port
	 * @throws IOException 
	 * @throws ClassNotFoundException 
	 */
	public Node(int port,String dbName) throws IOException, ClassNotFoundException {
		//UDP between 1024 and 64535 since TCP port is set to UDP port + 1000
		if (port < 1024 || port > 64535)
			throw new IllegalArgumentException("Port has to be in range 1024 - 64535!");
		Random rand = new Random();
		this.id = rand.nextLong();
		this.host = InetAddress.getLocalHost().getHostAddress();
		this.port = port;
		this.DIR_NAME = dbName;
		//Initialize shared directory/database
		initSharedDirectory();
		//Fire up TCP file server
		new FileServer(this).start();
		//Fire up listening thread
		new Listener(this).start();
		//Fire up pinging thread
		new PingNeighbors(this).start();
		//Fire up reaper thread
		new Reaper(this).start();
	}
	
	/**
	 * Special constructor for node0. Pass in 
	 * id manually instead of randomizing. 
	 * This is necessary when nodeX tries to
	 * connect to node0. nodeX will have to know
	 * node0's id number to connect. Hence setting
	 * node0's id manually makes it easier to construct
	 * a neighbor representing node0.
	 * 
	 * @param port
	 * @param id Default value = 0
	 * @throws ClassNotFoundException 
	 * @throws UnknownHostException
	 */
	public Node(int port,long id,String dbName) throws IOException, ClassNotFoundException {
		if (port < 1024 || port > 64535)
			throw new IllegalArgumentException("Port has to be in range 1024 - 64535!");
		this.id = id;
		this.host = InetAddress.getLocalHost().getHostAddress();
		this.port = port;
		this.DIR_NAME = dbName;
		//Initialize shared directory/database
		initSharedDirectory();
		//Fire up TCP file server
		new FileServer(this).start();
		//Fire up listening thread
		new Listener(this).start();
		//Fire up pinging thread
		new PingNeighbors(this).start();
		//Fire up reaper thread
		new Reaper(this).start();
	}
	
	/**
	 * Return shared directory.
	 * @return DIR_NAME
	 */
	public String getDir() {
		return this.DIR_NAME;
	}
	
	/**
	 * Get the node's port
	 * @return port
	 */
	public int getPort() {
		return this.port;
	}
	
	/**
	 * Get the node's ip address
	 * @return port
	 */
	public long getId() {
		return this.id;
	}
	
	/**
	 * Get the node's ip address
	 * @return port
	 */
	public String getHost() {
		return this.host;
	}
	
	/**
	 * Get neighbors list
	 * @return neighbors
	 */
	public List<Neighbor> getNeighbors(){
		return this.neighbors;
	}
	
	/**
	 * This method adds neighbors to the neighbors list.
	 * Raises exception if the neighbors list exceeds the limit.
	 * @param n
	 * @throws Exception
	 */
	public void addNeighbor(Neighbor n) throws Exception {
		if (this.neighbors.size() >= this.MAX_NEIGHBORS)
			throw new Exception("Neighbor's maxed out, can't add anymore!");
		if (this.toNeighbor().equals(n))
			throw new Exception("Can't add thyself to neighbors list!");
		if (!this.neighbors.contains(n))
			this.neighbors.add(n);
	}
	
	/**
	 * Remove neighbor from neighbors list.
	 * @param n
	 * @return True if neighbor was removed
	 */
	public boolean removeNeighbor(Neighbor n) {
		return this.neighbors.remove(n);
	}
	
	/**
	 * This method sends out a message to 
	 * a given neighbor.
	 * @throws IOException 
	 */
	public void send(Message m, Neighbor n) throws IOException {
		InetAddress ip = InetAddress.getByName(n.getHost());
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		ObjectOutput out = new ObjectOutputStream(outputStream);
		out.writeObject(m);
		byte[] buffer = outputStream.toByteArray();
		DatagramSocket ds = new DatagramSocket();
		DatagramPacket packet = new DatagramPacket(buffer,buffer.length,ip,n.getPort());
		ds.send(packet);
	}
	
	/**
	 * Given a query string, this method returns true,
	 * if this node maintains a record with the given
	 * name. 
	 * @param query
	 * @return True if record associated with query exists
	 */
	public boolean search(String query) {
		return this.files.contains(query);
	}
	
	/**
	 * This method initializes the database Hashet by adding 
	 * all file names in the given directory. The directory
	 * is assumed to contain all the files shared by this 
	 * node.
	 * @param dirName Name of shared directory
	 */
	public void initSharedDirectory() {
		System.out.println("Initializing DB...\nShared DIR: " + this.DIR_NAME + "/");
		String[] filenames = new File(this.DIR_NAME).list();
		for (String fname: filenames) {
			this.files.add(fname);
			System.out.println("---> " + fname);
		}
	}
	
	/**
	 * This method returns the neighbor
	 * representation of a Node. A Neighbor
	 * is just a concise representation of 
	 * the Node class.
	 * @return neighbor shadow
	 */
	public Neighbor toNeighbor() {
		return new Neighbor(this.getId(),this.getHost(),this.getPort());
	}
	
	/**
	 * Get the string representation of a neighbor.
	 */
	@Override
	public String toString() {
		return "N_" + (this.id % 1000) + " - " + this.getHost() + ":" + this.getPort();
	}
	
	/**
	 * Compare this neighbor to another neighbor
	 * object.
	 */
	@Override
	public int compareTo(Object obj) {
		Node n = (Node) obj;
		if (this.id == n.id || (this.getHost().equals(n.getHost()) && this.getPort() == n.getPort()))
			return 0;
		return this.id - n.id > 0 ? 1 : -1;
	}
	
	
	/**
	 * Check if argument is equal to this
	 * Node.
	 */
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Node) {
			Node node = ((Node) obj);
			boolean addressMatch = this.getHost().equals(node.getHost()) && this.getPort() == node.getPort();
			return this.id == node.getId() || addressMatch;
		}
		return false;
	} 
	
	/**
	 * The main method fires up one node. The very first node
	 * (node0), is assumed to be popular. It only requires running
	 * as follows: <br/><br/>
	 * 
	 * java Node port=##### local_database <br/><br/>
	 * 
	 * All other nodes will require the address of node0 or another
	 * active node to join the network. i.e. <br/><br/>
	 * 
	 * java Node port=##### local_database node0IP=X.X.X.X node0Port=#####<br/><br/>
	 * 
	 * @param args[0] Node's port number
	 * @param args[1] Local file this node is sharing. (Provide path to file)
 	 * @param args[2] IP of well known active node (Empty for node0)
	 * @param args[3] Port of well known active node (Empty for node0)
	 * @throws Exception 
	 */
	public static void main(String[] args) throws Exception {
		if (args.length != 2 && args.length != 4 && args.length != 5) {
			System.err.println("Incorrect number of arguments provided.");
			System.err.println("How to run for node0: java Node ip=X.X.X.X port=#####");
			System.err.println("How to run for nodeX: java Node ip=X.X.X.X port=##### node0IP=X.X.X.X node0Port=#####");
			System.err.println("How to run for nodeX with query: java Node ip=X.X.X.X port=##### node0IP=X.X.X.X node0Port=##### query");
			return ;
		}
		int port = Integer.parseInt(args[0]);
		String dbName = args[1];
		//Setup node0
		if (args.length == 2) {
			//Initialize node0
			Node node0 = new Node(port,Node.NODE_0_ID,dbName);
			
			//Infinite loop user interaction
			while(true) {
				//For GUI
				
			}
		}
		//Setup nodeX.
		else if (args.length > 2) {
			//Initialize node0
			Node nodeX = new Node(port,dbName);
			
			//Create neighbor0 (Shadow of node0)
			Neighbor n0 = new Neighbor(Node.NODE_0_ID,args[2],Integer.parseInt(args[3]));
			//Add neighbor0 to list of neighbors
			nodeX.addNeighbor(n0);
			System.out.println("Added: " + n0);
			if (args.length == 5) {
				System.out.println("Search: " + args[4]);
				Message queryMessage = new Message(nodeX.toNeighbor(),4,nodeX.getPort());
				//Set query String
				queryMessage.setSearchString(args[4]);
				//Query all neighbors
				Iterator<Neighbor> iter = nodeX.getNeighbors().iterator();
				while (iter.hasNext()) {
					//Pick next neighbor
					Neighbor n = iter.next();
					//Send message to neighbor
					nodeX.send(queryMessage,n);
					//Cache query
					nodeX.QUERY_CACHE.add(queryMessage.getId());
					System.out.println("Queried: " + n);
					
				}
			}
			
			//Infinite loop user interaction
			while(true) {
				//For GUI
				
			}
		}
	}
	 
}